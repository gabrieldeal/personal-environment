#!/usr/bin/env sh
# -*- shell-script -*-

read_configuration() {
    local config_file="$HOME/.pomodoro-bash"
    [ -e "$config_file" ] && . "$config_file"

    : ${UPDATE_INTERVAL_SECONDS:=1}
    : ${WORK_SECONDS:=$(( 25 * 60 ))}
    : ${BREAK_SECONDS:=$(( 5 * 60 ))}
    : ${PROMPT_TO_START:=""}
    INTERACTIVE_COMMANDS_PROMPT="Start new pomo (s), start pomo with a goal (g), take a break (b), quit (q)? "

    # ASCII art from dogsay. MIT License. Copyright (c) 2015 Forrest Fleming.
    # https://github.com/ffleming/dogsay
    : ${WORKING_LARGE_ASCII_ART:="$HOME/local/pomodoro-bash/large-dino.txt"}
    : ${WORKING_MEDIUM_ASCII_ART:="$HOME/local/pomodoro-bash/medium-dino.txt"}
    : ${TAKING_A_BREAK_LARGE_ASCII_ART:="$HOME/local/pomodoro-bash/large-dog.txt"}
    : ${TAKING_A_BREAK_MEDIUM_ASCII_ART:="$HOME/local/pomodoro-bash/medium-dog.txt"}

    # "FREE RED TOMATO CLIP ART" by OpenGameArt.org is public domain.
    # http://www.clipartlord.com/category/food-clip-art/vegetables-clip-art/tomato-clip-art/
    : ${WORKING_ICON:="$HOME/local/pomodoro-bash/tomato13.png"}

    # Public domain dog. https://thenounproject.com/term/dog/364/
    : ${TAKING_A_BREAK_ICON:="$HOME/local/pomodoro-bash/dog.svg"}

    # I made this one.
    : ${WAITING_TO_START_ICON:="$HOME/local/pomodoro-bash/circle_question.svg"}

    : ${WORKING_LARGE_BANNER:="$HOME/local/pomodoro-bash/banner-large-working.txt"}
    : ${TAKING_A_BREAK_LARGE_BANNER:="$HOME/local/pomodoro-bash/banner-large-taking-a-break.txt"}
    : ${WAITING_TO_START_LARGE_BANNER:="$HOME/local/pomodoro-bash/banner-large-waiting-to-start.txt"}

    : ${LOG_FILE:=/dev/null}

    # No default value for SET_CHAT_STATUS_COMMAND.

    : ${APPLICATION_INDICATOR_COMMAND:="$(find_command indicator-sysmonitor)"}
    : ${APPLICATION_INDICATOR_CONFIG_FILE:="${TMPDIR:-/tmp}/$USER-pomodoro-indicator-config.txt"}
    : ${APPLICATION_INDICATOR_ICON_FILE:="${TMPDIR:-/tmp}/$USER-pomodoro-indicator-icon.txt"}

    initialize_notification_configuration
    initialize_audio_configuration
}

initialize_notification_configuration() {
    [ -n "$NOTIFICATION_COMMAND" ] && return

    local platform="$(uname)"
    if [ $platform = 'Darwin' ]; then
	NOTIFICATION_COMMAND="osascript -e 'display notification \"%s\" with title \"Pomodoro\"'"
	return
    fi

    # https://wiki.ubuntu.com/NotifyOSD
    # https://developer.gnome.org/notification-spec/
    local default_notification_command="$(find_command notify-send)"
    if [ -z "$NOTIFICATION_COMMAND" ] && [ -n "$default_notification_command" ]; then
	NOTIFICATION_COMMAND="\"$default_notification_command\" \"%s\""
    fi
}

initialize_audio_configuration() {
    local audio_type="ogg"
    initialize_audio_player_configuration "mp3" "madplay" "mpg123" "mpg321" "afplay" && audio_type="mp3"
    initialize_audio_player_configuration "ogg" "paplay" "sndfile-play" "beep" && audio_type="ogg"

    # "Text Message Alert 3 Sound" by Daniel Simion is licensed under CC BY 3.0.
    # http://soundbible.com/2156-Text-Message-Alert-3.html
    # https://creativecommons.org/licenses/by/3.0/
    : ${WAITING_TO_START_AUDIO_FILE:="$HOME/local/pomodoro-bash/alert.$audio_type"}

    # "Barking of a dog" by Wikimedia Commons is licensed under CC BY 3.0.
    # https://commons.wikimedia.org/wiki/File:Barking_of_a_dog.ogg
    # https://creativecommons.org/licenses/by/3.0/
    : ${TAKING_A_BREAK_AUDIO_FILE:="$HOME/local/pomodoro-bash/Barking_of_a_dog.$audio_type"}

    # "Tyrannosaurus Rex Roar Sound" from soundbible.com is public domain.
    # http://soundbible.com/1748-Tyrannosaurus-Rex-Roar.html
    : ${WORKING_AUDIO_FILE:="$HOME/local/pomodoro-bash/Tyrannosaurus Rex Roar.$audio_type"}
}

initialize_audio_player_configuration() {
    local audio_type="$1"
    shift
    # local audio_players="$@"

    [ -n "$AUDIO_PLAYER_COMMAND" ] && return 1

    local audio_player="$(find_command "$@")"
    [ -z "$audio_player" ] && return 1

    AUDIO_PLAYER_COMMAND="\"$audio_player\" \"%s\""
    return 0

}

read_command_line_options() {
    while [ "$#" -gt 0 ]; do
	case "$1" in
	    -w)
		WORK_SECONDS="$2"
		shift
		shift
		;;
	    -b)
		BREAK_SECONDS="$2"
		shift
		shift
		;;
	    -p)
		PROMPT_TO_START=1
		shift
		;;
	    -h|*)
		printf "pomodoro-bash [ -w WORK_SECONDS ] [ -b BREAK_SECONDS ] [ -p ]\n"
		printf "\nSee the top of $0 for configuration hints.\n"
		exit 0
		;;
	esac
    done

    validate_timer_duration "$WORK_SECONDS"
    validate_timer_duration "$BREAK_SECONDS"
}

validate_timer_duration() {
    local duration_seconds="$1"

    is_integer "$duration_seconds" || fail "Duration '$duration_seconds' is not an integer!"
    [ $duration_seconds -ge $(( 60 * 60 )) ] && fail "Duration '$duration_seconds' seconds is too long!"
}

is_integer() {
    local value="$1"

    [ -n "${value##*[!0-9]*}" ]
    return $?
}

print_countdown_time() {
    local screen_type="$1"
    local size_category="$2"
    local end_date="$3"

    local seconds_left=$(( $end_date - $now ))
    local formatted_time_left="$(format_seconds_as_hh_mm $seconds_left)"
    formatted_time_left="$(start_text_standout_mode)$formatted_time_left$(end_text_standout_mode)"

    # Using sed instead of variable substitutions because some of the
    # ASCII art contains special shell characters.
    "print_${size_category}_${screen_type}_time" | sed "s/\$time/$formatted_time_left/" | grep -v '^#'
}

print_tiny_break_time() { printf '$time\n'; }
print_small_break_time() { print_tiny_break_time; }
print_medium_break_time() { cat "$TAKING_A_BREAK_MEDIUM_ASCII_ART"; }
print_large_break_time() { cat "$TAKING_A_BREAK_LARGE_ASCII_ART"; }

print_tiny_work_time() { printf '$time\n'; }
print_small_work_time() { print_tiny_work_time; }
print_medium_work_time() { cat "$WORKING_MEDIUM_ASCII_ART"; }
print_large_work_time() { cat "$WORKING_LARGE_ASCII_ART"; }

print_tiny_break_banner() { printf "Break!\n"; }
print_small_break_banner() { print_large_break_banner; }
print_medium_break_banner() { print_large_break_banner; }
print_large_break_banner() { cat "$TAKING_A_BREAK_LARGE_BANNER"; }

print_tiny_ready_banner() { printf "Ready?\n"; }
print_small_ready_banner() { print_large_ready_banner; }
print_medium_ready_banner() { print_large_ready_banner; }
print_large_ready_banner() { cat "$WAITING_TO_START_LARGE_BANNER"; }

print_tiny_work_banner() { printf "Focus!\n"; }
print_small_work_banner() { print_large_work_banner; }
print_medium_work_banner() { print_large_work_banner; }
print_large_work_banner() { cat "$WORKING_LARGE_BANNER"; }

find_command() {
    for command in "$@"
    do
	command -v "$command" >/dev/null 2>&1
	if [ $? = 0 ]; then
	    printf "%s" "$command"
	    return
	fi
    done
}

run_command() {
    local command_format="$1"
    local command_argument="$2"

    local command="$(printf "$command_format" "$command_argument")"
    eval "$command" >>"$LOG_FILE" 2>&1 &
}

fail() {
    echo "$*" 1>&2
    exit 1
}

handle_interactive_command() {
    local command="$1"

    case "$command" in
	s)
	    clear_screen
	    printf "Starting a new pomo..."
	    main_loop
	    ;;
	g)
	    clear_screen
	    show_cursor
	    printf "What is your goal for this pomo? "
	    read goal
	    printf "Starting a new pomo..."
	    main_loop "$goal"
	    ;;
	q)
	    tear_down
	    exit 0
	    ;;
	b)
	    clear_screen
	    printf "\nTaking a break..."
	    do_break_countdown
	    prompt_to_start
	    main_loop
	    ;;
    esac

    return 1
}

read_char() {
    local timeout_seconds="$1"

    local timeout_args="${timeout_seconds:+min 0 time $(($timeout_seconds * 10))}"
    local old_settings="$(stty -g)"
    stty raw isig -echo $timeout_args
    printf '%s' $(dd bs=1 count=1 2>/dev/null)
    stty $old_settings
}

get_lines() { echo "$1" | wc -l; }
get_columns() {
    local text="$1"

    local IFS='
'
    local columns=0
    for line in $text
    do
	[ ${#line} -gt $columns ] && columns=${#line}
    done
    echo $columns
}

does_text_fit_dimensions() {
    local text="$1"
    local screen_lines="$2"
    local screen_columns="$3"

    local text_lines="$(get_lines "$text")"
    local text_columns="$(get_columns "$text")"
    [ $screen_lines -ge $text_lines ] && [ $screen_columns -ge $text_columns ]
    return $?
}

LAST_SCREEN_COLUMNS=0
LAST_SCREEN_LINES=0
LAST_SCREEN_TYPE=0
update_screen_category() {
    local screen_type="$1"

    local screen_lines="$(tput lines)"
    local screen_columns="$(tput cols)"

    if [ $LAST_SCREEN_LINES -eq $screen_lines ] && [ $LAST_SCREEN_COLUMNS -eq $screen_columns ] && [ $LAST_SCREEN_TYPE = $screen_type ]; then
	return
    fi
    LAST_SCREEN_COLUMNS="$screen_columns"
    LAST_SCREEN_LINES="$screen_lines"
    LAST_SCREEN_TYPE="$screen_type"

    for size_category in large medium small
    do
	local output="$("print_${screen_type}_screen" "$size_category" "$@")"
	if does_text_fit_dimensions "$output" "$screen_lines" "$screen_columns"; then
	   SIZE_CATEGORY="$size_category"
	   return
	fi
    done

    SIZE_CATEGORY=tiny
}

print_screen() {
    local screen_type="$1"
    shift

    update_screen_category "$screen_type" "$@"
    "print_${screen_type}_screen" "$SIZE_CATEGORY" "$@"
}

print_ready_screen() {
    local size_category="$1"

    "print_${size_category}_ready_banner"
    printf "\n%s[s] " "$INTERACTIVE_COMMANDS_PROMPT"
}

print_break_screen() { print_count_down_screen "break" "$@"; }
print_work_screen() { print_count_down_screen "work" "$@"; }
print_count_down_screen() {
    local screen_type="$1"
    local size_category="$2"
    local end_date="$3"
    local goal="$4"
    local command_result="$5"

    local banner_message="$("print_${size_category}_${screen_type}_banner")"
    local countdown_message="$(print_countdown_time "$screen_type" "$size_category" "$end_date")"

    clear_screen
    printf "%s\n" "$banner_message"
    [ -n "$goal" ] && printf "Goal: %s\n" "$goal"
    printf "%s\n" "$countdown_message"
    printf "%s %s" "$INTERACTIVE_COMMANDS_PROMPT" "$command_result"
}

count_down() {
    local screen_type="$1"
    local countdown_printer="$2"
    local seconds="$3"
    local goal="$4"

    hide_cursor

    local command_result=
    local now=$(date +%s)
    local end_date=$(( $now + $seconds ))
    while [ $end_date -gt $now ]; do
	print_screen "$screen_type" "$end_date" "$goal" "$command_result"

	local wait_seconds=1
	local command="$(read_char $wait_seconds)"
	discard_stdin
	if [ -n "$command" ]; then
	    handle_interactive_command "$command"
	    command_result="Huh? "
	fi

	now=$(date +%s)
    done
}

format_seconds_as_hh_mm() {
    local seconds="$1"

    local minutes=$(( $seconds % 3600 / 60 ))
    local seconds=$(( $seconds % 60 ))
    printf "%02d:%02d\n" $minutes $seconds
}

tear_down() {
    stty sane
    show_cursor
    tear_down_application_indicator
    set_chat_status "chat"
    printf "\nBye!\n"
    exit 0
}

tear_down_application_indicator() {
    if [ -n "$APPLICATION_INDICATOR_COMMAND" ]; then
       rm -f "$APPLICATION_INDICATOR_ICON_FILE" "$APPLICATION_INDICATOR_CONFIG_FILE"
       [ -n "$APPLICATION_INDICATOR_PID" ] && kill "$APPLICATION_INDICATOR_PID"
    fi
}

# https://github.com/fossfreedom/indicator-sysmonitor
initialize_application_indicator() {
    [ -z "$APPLICATION_INDICATOR_COMMAND" ] && return

    local json_config_format='
{
    "on_startup": false,
    "sensors": {
	"pomodoro": [
	    "",
	    "cat \"%s\""
	 ]
    },
    "interval": 2.0,
    "custom_text": "{pomodoro}"
}
'
    printf "$json_config_format" "$APPLICATION_INDICATOR_ICON_FILE" >"$APPLICATION_INDICATOR_CONFIG_FILE"
    printf "Starting..." >"$APPLICATION_INDICATOR_ICON_FILE"
    "$APPLICATION_INDICATOR_COMMAND" --config="$APPLICATION_INDICATOR_CONFIG_FILE" >>"$LOG_FILE" 2>&1 &
    APPLICATION_INDICATOR_PID="$!"
}

set_application_indicator_icon() {
    local icon_path="$1"

    [ -n "$APPLICATION_INDICATOR_COMMAND" ] && echo "USE_ICON:$icon_path" >"$APPLICATION_INDICATOR_ICON_FILE"
}

send_notification() {
    local message="$1"

    [ -n "$NOTIFICATION_COMMAND" ] && run_command "$NOTIFICATION_COMMAND" "$message"
}

set_chat_status() {
    local new_status="$1"

    [ -n "$SET_CHAT_STATUS_COMMAND" ] && run_command "$SET_CHAT_STATUS_COMMAND" "$new_status"
}

play_audio() {
    local audio_file="$1"

    if [ -n "$AUDIO_PLAYER_COMMAND" ]; then
	run_command "$AUDIO_PLAYER_COMMAND" "$audio_file"
    else
	printf ''
    fi
}

do_work_countdown() {
    local goal="$1"

    set_chat_status "dnd"
    set_application_indicator_icon "$WORKING_ICON"
    count_down "work" "$WORK_COUNTDOWN_PRINTER" $WORK_SECONDS "$goal"
}

do_break_countdown() {
    set_chat_status "chat"
    set_application_indicator_icon "$TAKING_A_BREAK_ICON"
    count_down "break" "$BREAK_COUNTDOWN_PRINTER" $BREAK_SECONDS
}

discard_stdin() {
    while [ -n "$(read_char 0)" ]; do
	:
    done
}

start_text_standout_mode() { tput smso; }
end_text_standout_mode() { tput rmso; }
hide_cursor() { tput civis; }
show_cursor() { tput cnorm; }
clear_screen() { tput clear; }

prompt_to_start() {
    set_application_indicator_icon "$WAITING_TO_START_ICON"

    clear_screen
    print_screen "ready"

    local default_command=s
    while true; do
	discard_stdin

	show_cursor
	local command="$(read_char | tr -d '\r\n')"
	hide_cursor

	[ -z "$command" ] && command="$default_command"

	handle_interactive_command "$command"
	printf "\nHuh? "
    done
}

initialize() {
    trap tear_down INT TERM HUP

    # Handling the WINCH signal was causing random freezes when I resized
    # the screen on Ubuntu 14.04:
    # trap handle_screen_resize WINCH

    initialize_application_indicator

    [ -n "$PROMPT_TO_START" ] && prompt_to_start
}

main_loop() {
    local goal="$1"

    while true; do
	play_audio "$WORKING_AUDIO_FILE"
	do_work_countdown "$goal"

	send_notification "Take a break!"
	play_audio "$TAKING_A_BREAK_AUDIO_FILE"
	do_break_countdown

	send_notification "Break over, man!"
	play_audio "$WAITING_TO_START_AUDIO_FILE"
	prompt_to_start
    done
}

read_configuration
read_command_line_options "$@"
initialize
main_loop
