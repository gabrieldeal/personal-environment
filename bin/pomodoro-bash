#!/bin/bash
# -*- shell-script -*-

# "FREE RED TOMATO CLIP ART" by OpenGameArt.org is public domain.
# http://www.clipartlord.com/category/food-clip-art/vegetables-clip-art/tomato-clip-art/
WORKING_ICON=~/local/pomodoro-bash/tomato13.png

# "Jump" by Alexander Blagochevsky is licenced under CC BY 3.0 / background
# and red circle added to the original.
# https://thenounproject.com/term/jumping-jack/150919/
# https://creativecommons.org/licenses/by/3.0/
TAKING_A_BREAK_ICON=~/local/pomodoro-bash/jump-white.png

# "Barking of a dog" by Wikimedia Commons is licensed under CC BY 3.0.
# https://commons.wikimedia.org/wiki/File:Barking_of_a_dog.ogg
# https://creativecommons.org/licenses/by/3.0/
TAKING_A_BREAK_SOUND=~/local/pomodoro-bash/Barking_of_a_dog.ogg

# I made this one.
WAITING_TO_START_ICON=~/local/pomodoro-bash/circle_question.svg

# "Text Message Alert 3 Sound" by Daniel Simion is licensed under CC BY 3.0.
# http://soundbible.com/2156-Text-Message-Alert-3.html
# https://creativecommons.org/licenses/by/3.0/
WAITING_TO_START_SOUND=~/local/pomodoro-bash/alert.ogg

APPLICATION_INDICATOR_CONFIG_FILE=/tmp/$USER-pomodoro-indicator-config.txt
APPLICATION_INDICATOR_ICON_FILE=/tmp/$USER-pomodoro-indicator-icon.txt

function find_command {
    for command in "$@"
    do
	which $command >/dev/null 2>&1
	if [ $? = 0 ]
	then
	    echo $command
	    return
	fi
    done
}

SET_CHAT_STATUS_COMMAND=`find_command set-chat-status`
BANNER_PRINTER_COMMAND=`find_command figlet banner toilet echo`

# https://github.com/ffleming/dogsay
BREAK_COUNTDOWN_PRINTER=`find_command dogsay cowsay dinosay echo`
WORK_COUNTDOWN_PRINTER=`find_command dinosay cowsay dogsay echo`

SOUND_PLAYER_COMMAND=`find_command paplay sndfile-play mpg123 beep`
APPLICATION_INDICATOR_COMMAND=`find_command indicator-sysmonitor`
NOTIFICATION_COMMAND=`find_command notify-send`

INTERACTIVE_COMMANDS="Start new pomo (s), take a break (b), quit (q)? "

UPDATE_INTERVAL_SECONDS=1
WORK_SECONDS=$(( 20 * 60 ))
BREAK_SECONDS=$(( 5 * 60 ))
PROMPT_TO_START=

while [ "$#" -gt 0 ]
do
    case $1 in
	-w)
	    WORK_SECONDS=$2
	    shift 2
	    ;;
	-b)
	    BREAK_SECONDS=$2
	    shift 2
	    ;;
	-p)
	    PROMPT_TO_START=1
	    shift
	    ;;
	-h|*)
	    echo "pomodoro-bash [ -w WORK_SECONDS ] [ -b BREAK_SECONDS ]"
	    exit 0
	    ;;
    esac
done

function fail {
    echo "$*" 1>&2
    exit 1
}

function check_required_value {
    local variable_name=$1
    local variable_value=${!variable_name}
    if [ -z "$variable_value" ]
    then
	fail "No value for $variable_name"
    fi
}

check_required_value BANNER_PRINTER_COMMAND
check_required_value BREAK_COUNTDOWN_PRINTER
check_required_value WORK_COUNTDOWN_PRINTER

function handle_command {
    local command=$1

    if [ "$command" = "s" ]
    then
	tput clear
	echo -ne "Starting a new pomo..."
	main_loop
    elif [ "$command" = "q" ]
    then
	echo -e "\nBye!"
	tear_down
	exit 0
    elif [ "$command" = "b" ]
    then
	tput clear
	echo -e "\nTaking a break..."
	do_break_count_down
	prompt_to_start_over
	main_loop
    fi

    return 1
}

function count_down {
    local message=$1
    local countdown_printer=$2
    local seconds=$3

    local banner_message=`$BANNER_PRINTER_COMMAND "$message"`

    local command_result=
    local now=`date +%s`
    local end_date=$(( $now + $seconds ))
    while [ $end_date -gt $now ]
    do
	seconds_left=$(( $end_date - $now ))
	local countdown_message=$($countdown_printer `format_seconds_as_hh_mm $seconds_left`)

	tput clear
	discard_stdin
	echo -e "$banner_message"
	echo -e "$countdown_message\n\n"
	echo -e "$INTERACTIVE_COMMANDS $command_result"

	local wait_seconds=1
	read -s -n 1 -t $wait_seconds command
	if [ -n "$command" ]
	then
	    handle_command "$command"
	    command_result="Huh? "
	fi

	now=`date +%s`
    done
}

function format_seconds_as_hh_mm {
    local seconds=$1

    local hours=`expr $seconds / 3600`
    if [ $hours -gt 0 ]
    then
	echo "I refuse to do that long of a pomodoro!" 1>&2
	exit 1
    fi

    local minutes=`expr $seconds  % 3600 / 60`
    local seconds=`expr $seconds % 60`
    printf "%02d:%02d\n" $minutes $seconds
}

function tear_down {
    tput cnorm
    tear_down_application_indicator
    set_chat_status chat
    exit 0
}

function tear_down_application_indicator {
    if [ -n "$APPLICATION_INDICATOR_COMMAND" ]
    then
       rm -f $APPLICATION_INDICATOR_ICON_FILE $APPLICATION_INDICATOR_CONFIG_FILE
       killall "$APPLICATION_INDICATOR_COMMAND"
    fi
}

# https://github.com/fossfreedom/indicator-sysmonitor
function initialize_application_indicator {
    if [ -n "$APPLICATION_INDICATOR_COMMAND" ]
    then
	echo '{"on_startup": false, "sensors": {"pomodoro": ["", "cat '$APPLICATION_INDICATOR_ICON_FILE'"] }, "interval": 2.0, "custom_text": "{pomodoro}"}' >$APPLICATION_INDICATOR_CONFIG_FILE
	echo "Starting..." >$APPLICATION_INDICATOR_ICON_FILE
	"$APPLICATION_INDICATOR_COMMAND" --config="$APPLICATION_INDICATOR_CONFIG_FILE" >/dev/null 2>&1 &
    fi
}

function set_application_indicator_icon {
    if [ -n "$APPLICATION_INDICATOR_COMMAND" ]
    then
	echo "USE_ICON:$1" >$APPLICATION_INDICATOR_ICON_FILE
    fi
}

# https://wiki.ubuntu.com/NotifyOSD
# https://developer.gnome.org/notification-spec/
function send_notification {
    if [ -n "$NOTIFICATION_COMMAND" ]
    then
	local message=$1
	local icon=$2

	"$NOTIFICATION_COMMAND" --urgency=normal --icon="$icon" "$message"
    fi
}

function set_chat_status {
    if [ -n "$SET_CHAT_STATUS_COMMAND" ]
    then
	local new_status=$1

	$SET_CHAT_STATUS_COMMAND $new_status &
    fi
}

function play_sound {
    if [ -n "$SOUND_PLAYER_COMMAND" ]
    then
	play_sound "$1" >/dev/null 2>&1
    else
	echo -ne ''
    fi
}

function do_interval_count_down {
    set_chat_status dnd
    set_application_indicator_icon "$WORKING_ICON"

    count_down 'F o c u s !' "$WORK_COUNTDOWN_PRINTER" $WORK_SECONDS
}

function do_break_count_down {
    play_sound "$TAKING_A_BREAK_SOUND"
    send_notification "Take a break!" "$TAKING_A_BREAK_ICON"
    set_chat_status chat
    set_application_indicator_icon "$TAKING_A_BREAK_ICON"

    count_down 'B r e a k !' "$BREAK_COUNTDOWN_PRINTER" $BREAK_SECONDS
}

function prompt_to_start_over {
    send_notification "Break over, man!" "$WORKING_ICON"
    play_sound "$WAITING_TO_START_SOUND"

    prompt_to_start
}

function discard_stdin {
    while read -t 0
    do
	read -s -n 1
    done
}

function hide_cursor {
    tput civis
}

function show_cursor {
    tput cnorm
}

function prompt_to_start {
    set_application_indicator_icon "$WAITING_TO_START_ICON"

    tput clear
    $BANNER_PRINTER_COMMAND "R e a d y ?"

    local default_command=s
    while true
    do
	discard_stdin
	echo -ne "\n$INTERACTIVE_COMMANDS [$default_command] "
	show_cursor
	read -n 1 command
	hide_cursor

	if [ -z "$command" ]
	then
	    command=$default_command
	fi

	handle_command $command
	echo -e "\nHuh?"
    done
}

function set_up {
    trap tear_down SIGINT SIGTERM SIGHUP
    initialize_application_indicator

    if [ -n "$PROMPT_TO_START" ]
    then
	prompt_to_start
    fi
}

function main_loop {
    tput civis
    while true
    do
	do_interval_count_down
	do_break_count_down
	prompt_to_start_over
    done
}

set_up
main_loop
