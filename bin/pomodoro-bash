#!/usr/bin/env sh

# shellcheck disable=SC2086
# SC2086 is "double quote to prevent globbing and word splitting". It gives too many false positives.

# TODO:
# Use https://github.com/matryer/bitbar to display status in the MacOS status menu.
# Get rid of `command -v`. https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=733511
# Get to run under /bin/posh
# Windows taskbar notification
#   Shell_NotifyIcon(): https://www.codeproject.com/kb/shell/stealthdialog.aspx
#   http://www.mingw.org/

read_configuration() {
    local config_file="$HOME/.pomodoro-bash"
    [ -e "$config_file" ] && . "$config_file"

    : ${UPDATE_INTERVAL_SECONDS:=1}
    : ${WORK_SECONDS:=$(( 25 * 60 ))}
    : ${BREAK_SECONDS:=$(( 5 * 60 ))}
    : ${PROMPT_TO_START:=""}
    INTERACTIVE_COMMANDS_PROMPT="Start new pomo (s), take a break (b), quit (q)? "

    # ASCII art from dogsay. MIT License. Copyright (c) 2015 Forrest Fleming.
    # https://github.com/ffleming/dogsay
    : ${WORKING_LARGE_ASCII_ART:="$HOME/local/pomodoro-bash/ascii-art/large-dino.txt"}
    : ${WORKING_MEDIUM_ASCII_ART:="$HOME/local/pomodoro-bash/ascii-art/medium-dino.txt"}
    : ${TAKING_A_BREAK_LARGE_ASCII_ART:="$HOME/local/pomodoro-bash/ascii-art/large-dog.txt"}
    : ${TAKING_A_BREAK_MEDIUM_ASCII_ART:="$HOME/local/pomodoro-bash/ascii-art/medium-dog.txt"}

    # "FREE RED TOMATO CLIP ART" by OpenGameArt.org is public domain.
    # http://www.clipartlord.com/category/food-clip-art/vegetables-clip-art/tomato-clip-art/
    : ${NOTIFICATION_ICON:="$HOME/local/pomodoro-bash/images/tomato13.ico"}
    : ${WORKING_ICON:="$HOME/local/pomodoro-bash/images/tomato13.png"}

    # Public domain dog. https://thenounproject.com/term/dog/364/
    : ${TAKING_A_BREAK_ICON:="$HOME/local/pomodoro-bash/images/dog.svg"}

    # I made this one.
    : ${WAITING_TO_START_ICON:="$HOME/local/pomodoro-bash/images/circle_question.svg"}

    : ${WORKING_LARGE_BANNER:="$HOME/local/pomodoro-bash/ascii-art/banner-large-working.txt"}
    : ${TAKING_A_BREAK_LARGE_BANNER:="$HOME/local/pomodoro-bash/ascii-art/banner-large-taking-a-break.txt"}
    : ${WAITING_TO_START_LARGE_BANNER:="$HOME/local/pomodoro-bash/ascii-art/banner-large-waiting-to-start.txt"}

    : ${LOG_FILE:=/dev/null}

    # No default value for SET_CHAT_STATUS_COMMAND.

    : ${APPLICATION_INDICATOR_COMMAND:="$(find_command indicator-sysmonitor)"}
    : ${APPLICATION_INDICATOR_CONFIG_FILE:="${TMPDIR:-/tmp}/$USER-${$}-pomodoro-indicator-config.txt"}
    : ${APPLICATION_INDICATOR_ICON_FILE:="${TMPDIR:-/tmp}/$USER-${$}-pomodoro-indicator-icon.txt"}
    APPLICATION_INDICATOR_CONFIG_TEMPLATE_FILE="$HOME/local/pomodoro-bash/config/indicator-sysmonitor-config.json"

    initialize_notification_configuration
    initialize_audio_configuration
}

initialize_notification_configuration() {
    [ -n "$NOTIFICATION_COMMAND" ] && return

    if command -v osascript >/dev/null; then
	NOTIFICATION_COMMAND="osascript -e 'display notification \"%s\" with title \"Pomodoro\"'"
    elif command -v notify-send >/dev/null; then
	NOTIFICATION_COMMAND="notify-send -i \"$NOTIFICATION_ICON\" Pomodoro \"%s\""
    elif command -v notifu >/dev/null; then
	NOTIFICATION_COMMAND="notifu /m \"%s\" /p Pomodoro /d 5000"
    fi
}

initialize_audio_configuration() {
    local audio_type=
    initialize_audio_player_configuration "madplay" "mpg123" "mpg321" "afplay" && audio_type="mp3"
    initialize_audio_player_configuration "paplay" "sndfile-play" "beep" && audio_type="ogg"
    if [ -z "$AUDIO_PLAYER_COMMAND" ] && command -v vlc >/dev/null; then
	AUDIO_PLAYER_COMMAND="vlc_play_sound \"%s\""
	audio_type="mp3"
    fi

    # "Text Message Alert 3 Sound" by Daniel Simion is licensed under CC BY 3.0.
    # http://soundbible.com/2156-Text-Message-Alert-3.html
    # https://creativecommons.org/licenses/by/3.0/
    : ${WAITING_TO_START_AUDIO_FILE:="$HOME/local/pomodoro-bash/audio/alert.$audio_type"}

    # "Barking of a dog" by Wikimedia Commons is licensed under CC BY 3.0.
    # https://commons.wikimedia.org/wiki/File:Barking_of_a_dog.ogg
    # https://creativecommons.org/licenses/by/3.0/
    : ${TAKING_A_BREAK_AUDIO_FILE:="$HOME/local/pomodoro-bash/audio/Barking_of_a_dog.$audio_type"}

    # "Tyrannosaurus Rex Roar Sound" from soundbible.com is public domain.
    # http://soundbible.com/1748-Tyrannosaurus-Rex-Roar.html
    : ${WORKING_AUDIO_FILE:="$HOME/local/pomodoro-bash/audio/Tyrannosaurus Rex Roar.$audio_type"}
}

initialize_audio_player_configuration() {
    [ -n "$AUDIO_PLAYER_COMMAND" ] && return 1

    local audio_player="$(find_command "$@")"
    [ -z "$audio_player" ] && return 1

    AUDIO_PLAYER_COMMAND="\"$audio_player\" \"%s\""
    return 0
}

vlc_play_sound() {
    local sound_file="$1"

    # CD to the sound directory because VLC can't handle UNIX-style paths.
    (cd "$(dirname "$sound_file")" \
	 && vlc --intf dummy --play-and-exit "$(basename "$sound_file")" >>"$LOG_FILE" 2>&1)
}

find_command() {
    for command in "$@"; do
	if command -v "$command" >/dev/null; then
	    printf "%s" "$command"
	    return
	fi
    done
}

fail() {
    echo "$*" 1>&2
    exit 1
}

read_command_line_options() {
    while [ "$#" -gt 0 ]; do
	case "$1" in
	    -w)
		WORK_SECONDS="$2"
		shift
		;;
	    -b)
		BREAK_SECONDS="$2"
		shift
		;;
	    -p)
		PROMPT_TO_START=1
		;;
	    -h|*)
		printf "pomodoro-bash [ -w WORK_SECONDS ] [ -b BREAK_SECONDS ] [ -p ]\n"
		printf "\nSee the top of %s for configuration hints.\n" "$0"
		exit 0
		;;
	esac
	shift
    done

    validate_timer_duration "$WORK_SECONDS"
    validate_timer_duration "$BREAK_SECONDS"
}

validate_timer_duration() {
    local duration_seconds="$1"

    is_integer "$duration_seconds" || fail "Duration '$duration_seconds' is not an integer!"
    [ "$duration_seconds" -ge $(( 60 * 60 )) ] && fail "Duration '$duration_seconds' seconds is too long!"
}

is_integer() {
    local value="$1"

    [ -n "${value##*[!0-9]*}" ]
    return $?
}

count_lines() { echo "$1" | wc -l; }
count_columns() {
    local text="$1"

    local IFS='
'
    local columns=0
    for line in $text; do
	[ ${#line} -gt $columns ] && columns=${#line}
    done
    echo "$columns"
}

does_text_fit_screen() {
    local text="$1"
    local screen_lines="$2"
    local screen_columns="$3"

    local text_lines="$(count_lines "$text")"
    local text_columns="$(count_columns "$text")"
    [ "$screen_lines" -ge "$text_lines" ] && [ "$screen_columns" -ge "$text_columns" ]
    return $?
}

LAST_SCREEN_COLUMNS=0
LAST_SCREEN_LINES=0
LAST_SCREEN_TYPE=0
update_screen_category() {
    local screen_type="$1"

    local screen_lines="$(tput lines)"
    local screen_columns="$(tput cols)"

    # Trapping the WINCH signal was causing random freezes when I resized the screen on Ubuntu 14.04.
    if [ "$LAST_SCREEN_LINES" -eq "$screen_lines" ] && [ "$LAST_SCREEN_COLUMNS" -eq "$screen_columns" ] && [ "$LAST_SCREEN_TYPE" = "$screen_type" ]; then
	return
    fi
    LAST_SCREEN_COLUMNS="$screen_columns"
    LAST_SCREEN_LINES="$screen_lines"
    LAST_SCREEN_TYPE="$screen_type"

    for size_category in large medium small; do
	local output="$("print_${screen_type}_screen" "$size_category" "$@")"
	if does_text_fit_screen "$output" "$screen_lines" "$screen_columns"; then
	   SIZE_CATEGORY="$size_category"
	   return
	fi
    done

    SIZE_CATEGORY=tiny
}

print_tiny_break_time() { printf "\$time\n"; }
print_small_break_time() { print_tiny_break_time; }
print_medium_break_time() { cat "$TAKING_A_BREAK_MEDIUM_ASCII_ART"; }
print_large_break_time() { cat "$TAKING_A_BREAK_LARGE_ASCII_ART"; }

print_tiny_work_time() { printf "\$time\n"; }
print_small_work_time() { print_tiny_work_time; }
print_medium_work_time() { cat "$WORKING_MEDIUM_ASCII_ART"; }
print_large_work_time() { cat "$WORKING_LARGE_ASCII_ART"; }

print_tiny_break_banner() { printf "Break!\n"; }
print_small_break_banner() { print_large_break_banner; }
print_medium_break_banner() { print_large_break_banner; }
print_large_break_banner() { cat "$TAKING_A_BREAK_LARGE_BANNER"; }

print_tiny_ready_banner() { printf "Ready?\n"; }
print_small_ready_banner() { print_large_ready_banner; }
print_medium_ready_banner() { print_large_ready_banner; }
print_large_ready_banner() { cat "$WAITING_TO_START_LARGE_BANNER"; }

print_tiny_work_banner() { printf "Focus!\n"; }
print_small_work_banner() { print_large_work_banner; }
print_medium_work_banner() { print_large_work_banner; }
print_large_work_banner() { cat "$WORKING_LARGE_BANNER"; }

print_screen() {
    local screen_type="$1"
    shift

    update_screen_category "$screen_type" "$@"
    "print_${screen_type}_screen" "$SIZE_CATEGORY" "$@"
}

print_ready_screen() {
    local size_category="$1"

    "print_${size_category}_ready_banner"
    printf "\n%s[s] " "$INTERACTIVE_COMMANDS_PROMPT"
}

print_break_screen() { print_count_down_screen "break" "$@"; }
print_work_screen() { print_count_down_screen "work" "$@"; }
print_count_down_screen() {
    local screen_type="$1"
    local size_category="$2"
    local seconds_left="$3"
    local command_result="$4"

    local banner_message="$("print_${size_category}_${screen_type}_banner")"
    local countdown_message="$(print_countdown_time "$screen_type" "$size_category" "$seconds_left")"

    clear_screen
    printf "%s\n" "$banner_message"
    printf "%s\n" "$countdown_message"
    printf "%s %s" "$INTERACTIVE_COMMANDS_PROMPT" "$command_result"
}

print_countdown_time() {
    local screen_type="$1"
    local size_category="$2"
    local seconds_left="$3"

    local formatted_time_left="$(format_seconds_as_hh_mm "$seconds_left")"
    formatted_time_left="$(start_text_standout_mode)$formatted_time_left$(end_text_standout_mode)"

    # Using sed instead of variable substitutions because some of the
    # ASCII art contains special shell characters.
    "print_${size_category}_${screen_type}_time" | sed "s/\$time/$formatted_time_left/" | grep -v '^#'
}

format_seconds_as_hh_mm() {
    local seconds="$1"

    local minutes=$(( seconds % 3600 / 60 ))
    local seconds=$(( seconds % 60 ))
    printf "%02d:%02d\n" $minutes $seconds
}

count_down() {
    local screen_type="$1"
    local seconds="$2"
    local icon="$3"

    hide_cursor

    local command_result=
    local now=$(date +%s)
    local end_date=$(( now + seconds ))
    while [ "$end_date" -gt "$now" ]; do
	local seconds_left=$(( end_date - now ))
	local minutes_left=$(( (seconds_left + 60 - 1) / 60 ))
	set_application_indicator "$icon" "${minutes_left}m"

	print_screen "$screen_type" "$seconds_left" "$command_result"

	local wait_seconds=1
	local command="$(read_char $wait_seconds)"
	discard_stdin
	if [ -n "$command" ]; then
	    handle_interactive_command "$command"
	    command_result="Huh? "
	fi

	now=$(date +%s)
    done
}
do_work_countdown() {
    play_audio "$WORKING_AUDIO_FILE"
    set_chat_status "dnd"
    count_down "work" "$WORK_SECONDS" "$WORKING_ICON"
}
do_break_countdown() {
    play_audio "$TAKING_A_BREAK_AUDIO_FILE"
    set_chat_status "chat"
    count_down "break" "$BREAK_SECONDS" "$TAKING_A_BREAK_ICON"
}

prompt_to_start() {
    play_audio "$WAITING_TO_START_AUDIO_FILE"
    set_application_indicator "$WAITING_TO_START_ICON" ""

    clear_screen
    print_screen "ready"

    local default_command=s
    while true; do
	discard_stdin

	show_cursor
	local command="$(read_char | tr -d '\r\n')"
	hide_cursor

	[ -z "$command" ] && command="$default_command"

	handle_interactive_command "$command"
	printf "\nHuh? "
    done
}

handle_interactive_command() {
    local command="$1"

    case "$command" in
	s)
	    clear_screen
	    printf "\nStarting a new pomo..."
	    main_loop
	    ;;
	q)
	    tear_down
	    exit 0
	    ;;
	b)
	    clear_screen
	    printf "\nTaking a break..."
	    do_break_countdown
	    prompt_to_start
	    main_loop
	    ;;
    esac

    return 1
}

read_char() {
    local timeout_seconds="$1"

    local timeout_args="${timeout_seconds:+min 0 time $((timeout_seconds * 10))}"
    local old_settings="$(stty -g)"
    stty raw isig -echo $timeout_args
    printf '%s' "$(dd bs=1 count=1 2>/dev/null)"
    stty "$old_settings"
}

discard_stdin() {
    while [ -n "$(read_char 0)" ]; do
	:
    done
}

start_text_standout_mode() { tput smso; }
end_text_standout_mode() { tput rmso; }
hide_cursor() { tput civis; }
show_cursor() { tput cnorm; }
clear_screen() { tput clear; }

run_command() {
    local command_format="$1"
    local command_argument="$2"

    # shellcheck disable=SC2059
    # SC2059 is "don't use variables in printf format.
    local command="$(printf "$command_format" "$command_argument")"

    # Don't log the command since it may have an auth token in it.
    eval "$command" >>"$LOG_FILE" 2>&1 &
}

send_notification() {
    local message="$1"

    [ -n "$NOTIFICATION_COMMAND" ] && run_command "$NOTIFICATION_COMMAND" "$message"
}

set_chat_status() {
    local new_status="$1"

    [ -n "$SET_CHAT_STATUS_COMMAND" ] && run_command "$SET_CHAT_STATUS_COMMAND" "$new_status"
}

play_audio() {
    local audio_file="$1"

    if [ -n "$AUDIO_PLAYER_COMMAND" ]; then
	run_command "$AUDIO_PLAYER_COMMAND" "$audio_file"
    else
	printf ''
    fi
}

set_application_indicator() {
    local icon_path="$1"
    local message="$2"

    [ -n "$message" ] && message="$message "
    [ -n "$APPLICATION_INDICATOR_COMMAND" ] && echo "${message}USE_ICON:$icon_path" >"$APPLICATION_INDICATOR_ICON_FILE"
}

tear_down_application_indicator() {
    [ -z "$APPLICATION_INDICATOR_COMMAND" ] && return

    rm -f "$APPLICATION_INDICATOR_ICON_FILE" "$APPLICATION_INDICATOR_CONFIG_FILE"
    [ -n "$APPLICATION_INDICATOR_PID" ] && kill "$APPLICATION_INDICATOR_PID"
}

# https://github.com/fossfreedom/indicator-sysmonitor
initialize_application_indicator() {
    [ -z "$APPLICATION_INDICATOR_COMMAND" ] && return

    local json_config_format="$(cat "$APPLICATION_INDICATOR_CONFIG_TEMPLATE_FILE")"

    # shellcheck disable=SC2059
    # SC2059 is "don't use variables in printf format.
    printf "$json_config_format" "$APPLICATION_INDICATOR_ICON_FILE" >"$APPLICATION_INDICATOR_CONFIG_FILE"

    printf "Starting..." >"$APPLICATION_INDICATOR_ICON_FILE"
    "$APPLICATION_INDICATOR_COMMAND" --config="$APPLICATION_INDICATOR_CONFIG_FILE" >>"$LOG_FILE" 2>&1 &
    APPLICATION_INDICATOR_PID="$!"
}

initialize() {
    ORIGINAL_STTY_SETTINGS="$(stty -g)"
    trap tear_down INT TERM HUP
    initialize_application_indicator
    [ -n "$PROMPT_TO_START" ] && prompt_to_start
}

tear_down() {
    [ -n "$ORIGINAL_STTY_SETTINGS" ] && stty $ORIGINAL_STTY_SETTINGS
    show_cursor
    tear_down_application_indicator
    set_chat_status "chat"
    printf "\nBye!\n"
    exit 0
}

main_loop() {
    while true; do
	do_work_countdown

	send_notification "Take a break!"
	do_break_countdown

	send_notification "Break over, man!"
	prompt_to_start
    done
}

read_configuration
read_command_line_options "$@"
initialize
main_loop
