#!/usr/bin/env sh
# -*- shell-script -*-

read_configuration() {
    local config_file="$HOME/.pomodoro-bash"
    [ -e "$config_file" ] && . "$config_file"

    : ${UPDATE_INTERVAL_SECONDS:=1}
    : ${WORK_SECONDS:=$(( 25 * 60 ))}
    : ${BREAK_SECONDS:=$(( 5 * 60 ))}
    : ${PROMPT_TO_START:=""}
    : ${INTERACTIVE_COMMANDS_PROMPT:="Start new pomo (s), start pomo with a goal (g), take a break (b), quit (q)? "}

    # "FREE RED TOMATO CLIP ART" by OpenGameArt.org is public domain.
    # http://www.clipartlord.com/category/food-clip-art/vegetables-clip-art/tomato-clip-art/
    : ${WORKING_ICON:="$HOME/local/pomodoro-bash/tomato13.png"}

    # ASCII art from dogsay. MIT License. Copyright (c) 2015 Forrest Fleming.
    # https://github.com/ffleming/dogsay
    : ${WORKING_LARGE_ASCII_ART:="$HOME/local/pomodoro-bash/large-dino.txt"}

    # ASCII art from dogsay. MIT License. Copyright (c) 2015 Forrest Fleming.
    # https://github.com/ffleming/dogsay
    : ${WORKING_MEDIUM_ASCII_ART:="$HOME/local/pomodoro-bash/medium-dino.txt"}

    # Public domain dog.
    # https://thenounproject.com/term/dog/364/
    : ${TAKING_A_BREAK_ICON:="$HOME/local/pomodoro-bash/dog.svg"}

    # ASCII art from dogsay. MIT License. Copyright (c) 2015 Forrest Fleming.
    # https://github.com/ffleming/dogsay
    : ${TAKING_A_BREAK_LARGE_ASCII_ART:="$HOME/local/pomodoro-bash/large-dog.txt"}

    # ASCII art from dogsay. MIT License. Copyright (c) 2015 Forrest Fleming.
    # https://github.com/ffleming/dogsay
    : ${TAKING_A_BREAK_MEDIUM_ASCII_ART:="$HOME/local/pomodoro-bash/medium-dog.txt"}

    # "Barking of a dog" by Wikimedia Commons is licensed under CC BY 3.0.
    # https://commons.wikimedia.org/wiki/File:Barking_of_a_dog.ogg
    # https://creativecommons.org/licenses/by/3.0/
    : ${TAKING_A_BREAK_SOUND:="$HOME/local/pomodoro-bash/Barking_of_a_dog.mp3"}

    # I made this one.
    : ${WAITING_TO_START_ICON:="$HOME/local/pomodoro-bash/circle_question.svg"}

    # "Text Message Alert 3 Sound" by Daniel Simion is licensed under CC BY 3.0.
    # http://soundbible.com/2156-Text-Message-Alert-3.html
    # https://creativecommons.org/licenses/by/3.0/
    : ${WAITING_TO_START_SOUND:="$HOME/local/pomodoro-bash/alert.mp3"}

    : ${LOG_FILE:=/dev/null}

    local default_sound_player_program=$(find_command paplay madplay sndfile-play mpg123 afplay beep)
    if [ -z "$SOUND_PLAYER_COMMAND" ] && [ -n "$default_sound_player_program" ]
    then
	SOUND_PLAYER_COMMAND="\"$default_sound_player_program\" \"%s\""
    fi

    # No default value for SET_CHAT_STATUS_COMMAND.

    : ${APPLICATION_INDICATOR_COMMAND:=$(find_command indicator-sysmonitor)}
    : ${APPLICATION_INDICATOR_CONFIG_FILE:="${TMPDIR:-/tmp}/$USER-pomodoro-indicator-config.txt"}
    : ${APPLICATION_INDICATOR_ICON_FILE:="${TMPDIR:-/tmp}/$USER-pomodoro-indicator-icon.txt"}

    # Mac OS: display notification "the message" with title "the title" subtitle "the subtitle"
    local default_notification_command=$(find_command notify-send)
    if [ -z "$NOTIFICATION_COMMAND" ] && [ -n "$default_notification_command" ]
    then
	NOTIFICATION_COMMAND="\"$default_notification_command\" \"%s\""
    fi
}

read_command_line_options() {
    while [ "$#" -gt 0 ]
    do
	case "$1" in
	    -w)
		WORK_SECONDS="$2"
		shift
		shift
		;;
	    -b)
		BREAK_SECONDS="$2"
		shift
		shift
		;;
	    -p)
		PROMPT_TO_START=1
		shift
		;;
	    -h|*)
		printf "pomodoro-bash [ -w WORK_SECONDS ] [ -b BREAK_SECONDS ] [ -p ]\n"
		printf "\nSee the top of $0 for configuration hints.\n"
		exit 0
		;;
	esac
    done

    validate_timer_duration $WORK_SECONDS
    validate_timer_duration $BREAK_SECONDS
}

validate_timer_duration() {
    local duration_seconds="$1"

    is_integer "$duration_seconds" || fail "Duration '$duration_seconds' is not an integer!"
    [ $duration_seconds -ge $(( 60 * 60 )) ] && fail "Duration '$duration_seconds' seconds is too long!"
}

is_integer() {
    local value="$1"

    [ -n "${value##*[!0-9]*}" ]
    return $?
}

print_countdown_time() {
    local type="$1"
    local end_date="$2"

    local seconds_left=$(( $end_date - $now ))
    local formatted_time_left="$(format_seconds_as_hh_mm $seconds_left)"
    formatted_time_left="$(start_text_standout_mode)$formatted_time_left$(end_text_standout_mode)"

    # Using sed instead of variable substitutions because some of the
    # ASCII art contains special shell characters.
    eval "print_${SIZE_CATEGORY}_${type}_time" | sed "s/\$time/$formatted_time_left/"
}

print_tiny_break_time() { printf '$time\n'; }
print_small_break_time() { print_tiny_break_time; }
print_medium_break_time() { cat "$TAKING_A_BREAK_MEDIUM_ASCII_ART"; }
print_large_break_time() { cat "$TAKING_A_BREAK_LARGE_ASCII_ART"; }

print_tiny_work_time() { printf '$time\n'; }
print_small_work_time() { print_tiny_work_time; }
print_medium_work_time() { cat "$WORKING_MEDIUM_ASCII_ART"; }
print_large_work_time() { cat "$WORKING_LARGE_ASCII_ART"; }

print_banner() {
    local type="$1"

    local banner_function_name="print_${SIZE_CATEGORY}_${type}_banner"
    eval "$banner_function_name"
}

print_tiny_break_banner() { printf "Break!\n"; }
print_small_break_banner() { print_large_break_banner; }
print_medium_break_banner() { print_large_break_banner; }
print_large_break_banner() {
    cat <<'EOT' -
 ____                          _      _
| __ )   _ __    ___    __ _  | | __ | |
|  _ \  | '__|  / _ \  / _` | | |/ / | |
| |_) | | |    |  __/ | (_| | |   <  |_|
|____/  |_|     \___|  \__,_| |_|\_\ (_)

EOT
}

print_tiny_ready_banner() { printf "Ready?\n"; }
print_small_ready_banner() { print_large_ready_banner; }
print_medium_ready_banner() { print_large_ready_banner; }
print_large_ready_banner() {
    cat <<'EOT' -
 ____                       _           ___
|  _ \    ___    __ _    __| |  _   _  |__ \
| |_) |  / _ \  / _` |  / _` | | | | |   / /
|  _ <  |  __/ | (_| | | (_| | | |_| |  |_|
|_| \_\  \___|  \__,_|  \__,_|  \__, |  (_)
				|___/
EOT
}

print_tiny_work_banner() { printf "Focus!\n"; }
print_small_work_banner() { print_large_work_banner; }
print_medium_work_banner() { print_large_work_banner; }
print_large_work_banner() {
    cat <<'EOT' -
 _____                                _
|  ___|   ___     ___   _   _   ___  | |
| |_     / _ \   / __| | | | | / __| | |
|  _|   | (_) | | (__  | |_| | \__ \ |_|
|_|      \___/   \___|  \__,_| |___/ (_)
EOT
}

find_command() {
    for command in "$@"
    do
	command -v "$command" >/dev/null 2>&1
	if [ $? = 0 ]
	then
	    printf "%s" "$command"
	    return
	fi
    done
}

run_command() {
    local command_format="$1"
    local command_argument="$2"

    local command="$(printf "$command_format" "$command_argument")"
    eval "$command" >>"$LOG_FILE" 2>&1 &
}

fail() {
    echo "$*" 1>&2
    exit 1
}

handle_interactive_command() {
    local command="$1"

    case "$command" in
	s)
	    clear_screen
	    printf "Starting a new pomo..."
	    main_loop
	    ;;
	g)
	    clear_screen
	    show_cursor
	    printf "What is your goal for this pomo? "
	    read goal
	    printf "Starting a new pomo..."
	    main_loop "$goal"
	    ;;
	q)
	    tear_down
	    exit 0
	    ;;
	b)
	    clear_screen
	    printf "\nTaking a break..."
	    do_break_countdown
	    prompt_to_start
	    main_loop
	    ;;
    esac

    return 1
}

# FIXME: derive this from the output data during initialization.
handle_screen_resize() {
    local lines=$(tput lines)
    local columns=$(tput cols)

    if [ $lines -ge 40 ] && [ $columns -ge 83 ]
    then
	SIZE_CATEGORY=large
    elif [ $lines -ge 24 ] && [ $columns -ge 49 ]
    then
	SIZE_CATEGORY=medium
    elif [ $lines -ge 11 ] && [ $columns -ge 49 ]
    then
	SIZE_CATEGORY=small
    else
	SIZE_CATEGORY=tiny
    fi
}

read_char() {
    local timeout_seconds=$1

    local timeout_args="${timeout_seconds:+min 0 time $(($timeout_seconds * 10))}"
    local old_settings="$(stty -g)"
    stty raw isig -echo $timeout_args
    printf '%s' $(dd bs=1 count=1 2>/dev/null)
    stty $old_settings
}

print_count_down_screen() {
    local type="$1"
    local end_date="$2"
    local goal="$3"
    local command_result="$4"

    local banner_message="$(print_banner "$type")"
    local countdown_message="$(print_countdown_time "$type" "$end_date")"

    clear_screen
    printf "%s\n" "$banner_message"
    [ -n "$goal" ] && printf "Goal: %s\n" "$goal"
    printf "%s\n" "$countdown_message"
    printf "%s %s" "$INTERACTIVE_COMMANDS_PROMPT" "$command_result"
}

count_down() {
    local type="$1"
    local countdown_printer="$2"
    local seconds="$3"
    local goal="$4"

    hide_cursor

    local command_result=
    local now=$(date +%s)
    local end_date=$(( $now + $seconds ))
    while [ $end_date -gt $now ]
    do
	handle_screen_resize
	print_count_down_screen "$type" "$end_date" "$goal" "$command_result"

	local wait_seconds=1
	local command="$(read_char $wait_seconds)"
	discard_stdin
	if [ -n "$command" ]
	then
	    handle_interactive_command "$command"
	    command_result="Huh? "
	fi

	now=$(date +%s)
    done
}

format_seconds_as_hh_mm() {
    local seconds=$1

    local minutes=$(( $seconds % 3600 / 60 ))
    local seconds=$(( $seconds % 60 ))
    printf "%02d:%02d\n" $minutes $seconds
}

tear_down() {
    stty sane
    show_cursor
    tear_down_application_indicator
    set_chat_status "chat"
    printf "\nBye!\n"
    exit 0
}

tear_down_application_indicator() {
    if [ -n "$APPLICATION_INDICATOR_COMMAND" ]
    then
       rm -f "$APPLICATION_INDICATOR_ICON_FILE" "$APPLICATION_INDICATOR_CONFIG_FILE"
       # Ick!!!
       killall "$APPLICATION_INDICATOR_COMMAND" >/dev/null 2>&1
    fi
}

# https://github.com/fossfreedom/indicator-sysmonitor
initialize_application_indicator() {
    if [ -z "$APPLICATION_INDICATOR_COMMAND" ]
    then
	return
    fi

    local json_config_format='
{
    "on_startup": false,
    "sensors": {
	"pomodoro": [
	    "",
	    "cat \"%s\""
	 ]
    },
    "interval": 2.0,
    "custom_text": "{pomodoro}"
}
'
    printf "$json_config_format" "$APPLICATION_INDICATOR_ICON_FILE" >"$APPLICATION_INDICATOR_CONFIG_FILE"
    printf "Starting..." >"$APPLICATION_INDICATOR_ICON_FILE"
    "$APPLICATION_INDICATOR_COMMAND" --config="$APPLICATION_INDICATOR_CONFIG_FILE" >>"$LOG_FILE" 2>&1 &
}

set_application_indicator_icon() {
    local icon_path="$1"

    [ -n "$APPLICATION_INDICATOR_COMMAND" ] && echo "USE_ICON:$icon_path" >"$APPLICATION_INDICATOR_ICON_FILE"
}

# https://wiki.ubuntu.com/NotifyOSD
# https://developer.gnome.org/notification-spec/
send_notification() {
    local message="$1"

    [ -n "$NOTIFICATION_COMMAND" ] && run_command "$NOTIFICATION_COMMAND" "$message"
}

set_chat_status() {
    local new_status="$1"

    [ -n "$SET_CHAT_STATUS_COMMAND" ] && run_command "$SET_CHAT_STATUS_COMMAND" "$new_status"
}

play_sound() {
    local sound_file="$1"

    if [ -n "$SOUND_PLAYER_COMMAND" ]
    then
	run_command "$SOUND_PLAYER_COMMAND" "$sound_file"
    else
	printf ''
    fi
}

do_work_countdown() {
    local goal="$1"

    set_chat_status "dnd"
    set_application_indicator_icon "$WORKING_ICON"

    count_down "work" "$WORK_COUNTDOWN_PRINTER" $WORK_SECONDS "$goal"
}

do_break_countdown() {
    set_chat_status "chat"
    set_application_indicator_icon "$TAKING_A_BREAK_ICON"

    count_down "break" "$BREAK_COUNTDOWN_PRINTER" $BREAK_SECONDS
}

discard_stdin() {
    while [ -n "$(read_char 0)" ]
    do
	:
    done
}

start_text_standout_mode() {
    tput smso
}

end_text_standout_mode() {
    tput rmso
}

hide_cursor() {
    tput civis
}

show_cursor() {
    tput cnorm
}

clear_screen() {
    tput clear
}

prompt_to_start() {
    set_application_indicator_icon "$WAITING_TO_START_ICON"

    clear_screen
    eval "print_${SIZE_CATEGORY}_ready_banner"

    local default_command=s
    while true
    do
	discard_stdin
	printf "\n%s [%s] " "$INTERACTIVE_COMMANDS_PROMPT" "$default_command"

	show_cursor
	local command="$(read_char | tr -d '\r\n')"
	hide_cursor

	[ -z "$command" ] && command=$default_command

	handle_interactive_command "$command"
	printf "\nHuh?"
    done
}

initialize() {
    trap tear_down INT TERM HUP

    # Handling the WINCH signal was causing random freezes when I resized
    # the screen on Ubuntu 14.04:
    # trap handle_screen_resize WINCH

    handle_screen_resize
    initialize_application_indicator

    [ -n "$PROMPT_TO_START" ] && prompt_to_start
}

main_loop() {
    local goal="$1"

    while true
    do
	do_work_countdown "$goal"

	send_notification "Take a break!"
	play_sound "$TAKING_A_BREAK_SOUND"
	do_break_countdown

	send_notification "Break over, man!"
	play_sound "$WAITING_TO_START_SOUND"
	prompt_to_start
    done
}

read_configuration
read_command_line_options "$@"
initialize
main_loop
